/*
 * generated by Xtext
 */
package org.modelversioning.emfprofile.decoration.scoping

import java.util.ArrayList
import java.util.HashSet
import java.util.Set
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.modelversioning.emfprofile.Stereotype
import org.modelversioning.emfprofile.decoration.decorationLanguage.Activation
import org.modelversioning.emfprofile.decoration.decorationLanguage.DecorationDescription
import org.modelversioning.emfprofile.decoration.decorationLanguage.DecorationModel
import org.modelversioning.emfprofile.decoration.decorationLanguage.SimpleText
import org.modelversioning.emfprofile.decoration.decorationLanguage.Text

import static org.modelversioning.emfprofile.decoration.DecorationLanguageUtil.*

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class EMFProfileDecorationLanguageScopeProvider extends AbstractDeclarativeScopeProvider {

	/*
	 * If namespace is used or not, the scopes that are resolved have different
	 * qualified names in IEObjectDescriptions. So, depending on it, if the namespace is used
	 * we create the scope directly with stereotypes, otherwise we delegate.
	 */
	def IScope scope_DecorationDescription_stereotype(DecorationDescription context, EReference ref){
		
		val model = context.eContainer as DecorationModel
		if(model.namespace != null){
			val sts = new ArrayList<Stereotype>
			sts.addAll(model.namespace.profile.stereotypes)
			Scopes::scopeFor(sts)
		} else {
			val scope = delegateGetScope(context, ref)
			scope
		}
	}

	/*
	 * for scopes in conditions 
	 */
	def IScope scope_EAttribute(Activation context, EReference ref){
		return getScopesOfEAttributes(context, ref)
	}
	
	/**
	 * For scopes in texts.
	 * <p>
	 * NOTE: for content assist to work right with cross-references,
	 * you have to provide the right argument-type for the context parameter.
	 * E.g., in this case do not use {@link SimpleText} as the type for the context, although 
	 * the stereotype's attribute is set in that grammar rule, but use the most common super type for context.
	 * In this case it is the {@link Text} grammar rule.
	 * </p> 
	 */
	def IScope scope_EAttribute(Text context, EReference ref){
		return getScopesOfEAttributes(context, ref)
	}

	/*
	 * When resolving the cross-reference to the attribute of a stereotype, which in the decoration language
	 * only happens in conditions and Text objects, we are only interested in attributes of the stereotype
	 * for which the decoration is defined. 
	 * We also need to collect the attributes of the parent/extended stereotypes if the stereotype has any ESuperTypes.
	 */
	private def IScope getScopesOfEAttributes(EObject context, EReference ref){
		val Set<EAttribute> attributes = new HashSet<EAttribute>
		val stereotype = getStereotype(context)
		attributes.addAll(stereotype.EAttributes)
		stereotype.ESuperTypes.forEach[st | attributes.addAll(st.EAttributes)]
		Scopes::scopeFor(attributes)
		//		new FilteringScope(delegateGetScope(condition, eReference), [
		//			// here comes the predicate
		//		])
	}
}
	