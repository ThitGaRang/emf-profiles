/*
 * generated by Xtext
 */
package org.modelversioning.emfprofile.decoration.validation

import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EcorePackage.Literals
import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl
import org.eclipse.xtext.validation.Check
import org.modelversioning.emfprofile.decoration.decorationLanguage.ComparisonOperator
import org.modelversioning.emfprofile.decoration.decorationLanguage.Condition
import org.modelversioning.emfprofile.decoration.decorationLanguage.DecorationDescription
import org.modelversioning.emfprofile.decoration.decorationLanguage.DecorationLanguagePackage
import org.modelversioning.emfprofile.decoration.decorationLanguage.DecorationModel
import org.modelversioning.emfprofile.decoration.decorationLanguage.IconDecoration

//import org.eclipse.xtext.validation.Check
/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class EMFProfileDecorationLanguageValidator extends AbstractEMFProfileDecorationLanguageValidator { //  public static val INVALID_NAME = 'invalidName'
	
	private static val uriConverter = new ExtensibleURIConverterImpl
	//
	//	@Check
	//	def checkGreetingStartsWithCapital(Greeting greeting) {
	//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
	//			warning('Name should start with a capital', 
	//					MyDslPackage.Literals.GREETING__NAME,
	//					INVALID_NAME)
	//		}
	//	}
	@Check
	def checkThatThereIsOnlyOneDecorationDescriptionForSameStereotype(DecorationDescription decorationDescription) {
		if ((decorationDescription.eContainer as DecorationModel).decorationDescriptions.exists[
			it != decorationDescription && it.stereotype == decorationDescription.stereotype])
			error('''Decoration description already defined for the «decorationDescription.stereotype.name»''', decorationDescription,
				DecorationLanguagePackage.Literals.DECORATION_DESCRIPTION__STEREOTYPE)
//		else if (decorationDescription.stereotype.abstract)
//			warning('Stereotype is abstract. Decoration description will be ignored by the runtime.', decorationDescription,
//				DecorationLanguagePackage.Literals.DECORATION_DESCRIPTION__STEREOTYPE)
//		else if (decorationDescription.stereotype.interface)
//			warning('Stereotype is defined to be an interface. Decoration description will be ignored by the runtime.', decorationDescription,
//				DecorationLanguagePackage.Literals.DECORATION_DESCRIPTION__STEREOTYPE)
	}
	
	@Check
	def checkIconDecorationLocationURI(IconDecoration iconDecoration){
//		println("\nIconDecoration location-uri check:")
//		println("\tlocation-uri original value: " + iconDecoration.location_uri)
		try {
			val locationURI = URI.createPlatformResourceURI(iconDecoration.location_uri, true)
//			println("\tlocation-uri converted to uri:" + locationURI.toString)
			
			if(uriConverter.exists(locationURI,null) == false){
				error('''The URI does not point to the icon location. Please use the path schema: "/Project_Name/path_to_icon_file"''', iconDecoration, DecorationLanguagePackage.Literals.ICON_DECORATION__LOCATION_URI)
			}
		}catch(IllegalArgumentException iae){
			println("\tCould not create URI, illegal argument exception is thrown: " + iae.message)
			error(iae.message, iconDecoration, DecorationLanguagePackage.Literals.ICON_DECORATION__LOCATION_URI)
		}
	}
	
	@Check
	def checkCondition(Condition condition){
		val EAttribute attribute = condition.attribute
		val ComparisonOperator operator = condition.operator
		val String value = condition.value

		switch attribute.EType {
			
			
			case attribute.EType == Literals.EBOOLEAN  || attribute.EType == Literals.ESTRING: {
				// if the type is boolean or string then only equal and unequal operator is right!
				if( ! (operator == ComparisonOperator.EQUAL || operator == ComparisonOperator.UNEQUAL)){
					error('''The comparison operator is not supported with the attribute type «attribute.EType.name»''', condition, DecorationLanguagePackage.Literals.CONDITION__OPERATOR)
				}
				
				// now we have to test if the value of the condition can be parsed into the attribute type
				if(attribute.EType == Literals.EBOOLEAN){
					if( ! (value == 'true' || value == 'false'))
						error('''Expecting a boolean value. Use ctrl-space to acctivate content assist.''', condition, DecorationLanguagePackage.Literals.CONDITION__VALUE)
				} else { // it is a string type
					if( ! ((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))))
						error('''Expecting a string literal.''', condition, DecorationLanguagePackage.Literals.CONDITION__VALUE)
				}
			}
			
			// now testing the values of the number type
			case attribute.EType == Literals.EINT : {
				try{
					Integer.parseInt(value)
					return
				} catch (NumberFormatException nfe){
					error('''Expecting an integer number.''', condition, DecorationLanguagePackage.Literals.CONDITION__VALUE)
				}
			}
			case attribute.EType == Literals.EFLOAT || attribute.EType == Literals.EDOUBLE : {
				try{
					Double.parseDouble(value)
					return
				} catch (NumberFormatException nfe){
					error('''Expecting a real number.''', condition, DecorationLanguagePackage.Literals.CONDITION__VALUE)
				}
			}
			
			default : 
				error('''The attribute of the type «attribute.EType.name» is not supported. 
				Supported types are: Boolean, String, Int, Float, Double''', condition, DecorationLanguagePackage.Literals.CONDITION__ATTRIBUTE)
		}
	}
}
